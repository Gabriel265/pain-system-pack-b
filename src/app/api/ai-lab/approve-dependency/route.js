import { Octokit } from "@octokit/core";
import { NextResponse } from "next/server";

export async function POST(req) {
  try {
    const { packages } = await req.json();

    if (!packages || !Array.isArray(packages) || packages.length === 0) {
      return NextResponse.json({ error: "No packages provided" }, { status: 400 });
    }

    const octokit = new Octokit({ auth: process.env.GITHUB_PAT });

    console.log("[approve] Starting direct commit for packages:", packages);

    const owner = process.env.GITHUB_OWNER;
    const repo = process.env.GITHUB_REPO;
    const branch = "ai-lab";

    // Helper: Update or create a file on the branch
    const updateOrCreateFile = async (path, updateContentFn, commitMessage) => {
      let currentContent = "{}"; // default for new/missing file
      let sha = null;

      try {
        const { data: file } = await octokit.request(
          "GET /repos/{owner}/{repo}/contents/{path}",
          { owner, repo, path, ref: branch }
        );

        currentContent = Buffer.from(file.content, "base64").toString("utf-8");
        sha = file.sha;
        console.log(`[approve] Found existing ${path} (sha: ${sha})`);
      } catch (err) {
        if (err.status === 404) {
          console.log(`[approve] ${path} does not exist on ${branch} — will create it`);
        } else {
          console.error(`[approve] Error fetching ${path}:`, err.message);
          throw err;
        }
      }

      const updatedContent = updateContentFn(currentContent);

      await octokit.request(
        "PUT /repos/{owner}/{repo}/contents/{path}",
        {
          owner,
          repo,
          path,
          message: commitMessage,
          content: Buffer.from(updatedContent).toString("base64"),
          ...(sha && { sha }), // omit sha for create
          branch,
        }
      );

      console.log(`[approve] ${sha ? "Updated" : "Created"} ${path} on ${branch}`);
    };

    // 1. Update package.json
    await updateOrCreateFile(
      "package.json",
      (content) => {
        let pkg;
        try {
          pkg = JSON.parse(content);
        } catch (e) {
          pkg = { dependencies: {}, devDependencies: {} };
        }
        if (!pkg.dependencies) pkg.dependencies = {};
        if (!pkg.devDependencies) pkg.devDependencies = {};

        packages.forEach((p) => {
          if (p.type === "dependencies") {
            pkg.dependencies[p.name] = p.version;
          } else if (p.type === "devDependencies") {
            pkg.devDependencies[p.name] = p.version;
          } else {
            console.warn(`[approve] Unknown dependency type '${p.type}' for ${p.name}`);
            pkg.dependencies[p.name] = p.version; // fallback
          }
        });

        return JSON.stringify(pkg, null, 2) + "\n";
      },
      "AI-Lab: add approved dependencies to package.json"
    );

    // 2. Update or create allowlist
    await updateOrCreateFile(
      ".github/allowed-dependencies.json",
      (content) => {
        let data;
        try {
          data = JSON.parse(content);
        } catch {
          data = { allowed: [] };
        }
        const allowedSet = new Set(data.allowed || []);
        packages.forEach((p) => allowedSet.add(p.name));
        data.allowed = Array.from(allowedSet).sort();
        return JSON.stringify(data, null, 2) + "\n";
      },
      "AI-Lab: add approved packages to allowlist"
    );

    // 3. Create or update PR (so Vercel deploys preview)
    const prTitle = `AI-Lab: Approved dependency installation (${packages.map(p => p.name).join(", ")})`;
    const prBody = `**Approved packages:**\n${packages.map(p => `- ${p.name}@${p.version} (${p.type})`).join("\n")}\n\nAuto-generated by AI Lab approval flow.\n\n**Preview:** https://${process.env.VERCEL_PROJECT_SLUG || repo}-git-ai-lab.vercel.app`;

    let prNumber;
    try {
      const { data: existing } = await octokit.request(
        "GET /repos/{owner}/{repo}/pulls",
        {
          owner,
          repo,
          head: `${owner}:ai-lab`,
          base: "ai-deploy",
          state: "open",
        }
      );

      if (existing.length > 0) {
        await octokit.request(
          "PATCH /repos/{owner}/{repo}/pulls/{pull_number}",
          {
            owner,
            repo,
            pull_number: existing[0].number,
            title: prTitle,
            body: prBody,
          }
        );
        prNumber = existing[0].number;
        console.log(`[approve] Updated existing PR #${prNumber}`);
      } else {
        const { data: pr } = await octokit.request(
          "POST /repos/{owner}/{repo}/pulls",
          {
            owner,
            repo,
            title: prTitle,
            body: prBody,
            head: "ai-lab",
            base: "ai-deploy",
          }
        );
        prNumber = pr.number;
        console.log(`[approve] Created new PR #${prNumber}`);
      }
    } catch (prErr) {
      console.error("[approve] Failed to create/update PR:", prErr.message);
      // Continue anyway — commit still happened
    }

    console.log("[approve] Direct commits complete — changes pushed to ai-lab");

    return NextResponse.json({
      success: true,
      message: "Dependencies approved and committed. PR created/updated. Vercel should deploy shortly. Check recent prompts in ~30s.",
      prNumber,
    });
  } catch (error) {
    console.error("[approve] Direct commit error:", error.message);
    if (error.response) {
      console.error("GitHub response:", error.response.status, error.response.data);
    }
    return NextResponse.json({ error: error.message || "Approval & commit failed" }, { status: 500 });
  }
}